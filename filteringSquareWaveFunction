  
// Function declarations
double takeSquareSignalSample(byte pin, int numReadings, int sampleTime);
void updateReference(int *s, int *c, int cyclePosition);  
  
  
// Call with these 'magic numbers' for best results
amplitude = takeSquareSignalSample(REFLECTANCEPIN, 1500, 87);



//---------------------------------------------------
// Function definitions
//  

 /*
  Correlate an analog signal to a 10kHz squarewave, returns the amplitude of the match

  Inputs: pin - Analog pin to read from
  numReadings - The number of samples to read
  sampleInterval - the amount of time in between each sample in microseconds 
  *Note read rates below 85 are not possible with analogRead()
*/

double takeSquareSignalSample( byte pin, int numReadings, int sampleInterval)
{
  // Record start time of a cycle and the first sample begin time
  static uint32_t tStart = micros(); // us; start time
  static uint32_t tbegin = tStart;

  double readVal = 0; //Value read from pin
  double sinDot = 0;  //Accumulator for square wvae at 0 degree phase
  double cosDot = 0;  //Accumulator for square wvae at 90 degree phase
  int i = 0; // index of reading 
  int s = 0; // sin sample multiplier (correlation to expected 0 phase signal)
  int c = 1; // cos sample multiplier (correlation to expected 90 phase signal)
  int cyclePosition = 0;  // position of sample in a 100us cycle

  while (i<numReadings){
    // Only take a reading once per sample interval
    uint32_t tNow = micros(); // us; time now
    if (tNow - tStart >= sampleInterval)
      {
        
        tStart += sampleInterval; // reset start time to take next sample at exactly the correct pd
        readVal = analogRead(pin); // Read value
        cyclePosition = (tNow-tbegin)%100; // Account for the shift on the 10khz wave signal so far
                                          //Take mod 100 to normalize back into standard period domain [0,99]us
        updateReference(&s,&c,cyclePosition); //update the expected references for sin and cos 
                                              //-> (-1,0,1) depending on location in waveform   
        sinDot += readVal*s; // add to accumulator
        cosDot += readVal*c; // add to accumulator            
      }
      i++;
    }

  // Apply normalization
  double normalize = 2.0/(numReadings);
  // Take the amplitude of the two combined    
  return sqrt((sinDot*sinDot + cosDot*cosDot))*normalize;
}

// Make a square wave reference signal to compare against for sampling, 
// update multipliers for the 0 and 90 degree phase offsets
void updateReference(int *s, int *c, int cyclePosition){
  
  if (cyclePosition == 0)
  {
    *s = 0;
    *c = -1;
  }
  else if (cyclePosition < 25)
  {
    *s = 1;
    *c = -1;
  }
    else if (cyclePosition == 25)
  {
    *s = 1;
    *c = 0;
  }
    else if (cyclePosition < 50)
  {
    *s = 1;
    *c = 1;
  }
    else if (cyclePosition == 50)
  {
    *s = 0;
    *c = 1;
  }
    else if (cyclePosition < 75)
  {
    *s = -1;
    *c = 1;
  }
    else if (cyclePosition == 75)
  {
    *s = -1;
    *c = 0;
  }
    else if (cyclePosition < 100)
  {
    *s = -1;
    *c = -1;
  }
    else 
  {
    // Error condition
    *s = -999;
    *c = -999;
  }

}
